### 第五章   初始化与清理 ###
--------------------------
##### 5.1 用构造器确保初始化  

1. 构造器的名称与类的名称相同  

2. 不带任何参数的构造器叫做**默认构造器**,又称**无参构造器**

3. 构造器也可以带有**形参列表**, 以便制定如何创建对象

4. 构造器是一种特殊的方法，没有**返回值**


##### 5.2 方法重载  

1. 方法名称相同，形参不同的方法，构成了**重载**

2. 区分重载方法: 每个方法都有独一无二的形参列表


##### 5.3 默认构造器

1. 默认构造器是一个没有形式参数的构造方法，它的作用是创建一个默认的对象

2. 如果你的类中没有默认构造器，编译器会给你增加一个默认的构造器

3. 如果已经定义了一个构造器（无论有无形参），编译器就不会给你增加一个默认构造器了


##### 5.4 this关键字

1. this.属性名称  
指的是访问类中的成员变量，用以区分“成员变量”和“局部变量”  

2. this.方法名称  
用以访问本类的成员方法

3. this()  
用以访问本类的默认构造函数(没有参数列表）

4. this(..)  
用以访问本类用参的构造方法


##### 5.5 清理：终结处理和垃圾回收  

1. Java的垃圾回收机制  
Java有垃圾回收器负责回收无用对象占据的内存资源，但垃圾回收器只知道释放那些经由new分配的内存，假如你的对象（并非使用new）获得一块“特殊”的内存区域，它不知道该如何释放该对象的这块“特殊”内存。

2. Java垃圾回收的时机  
Java的垃圾回收机制可以回收new分配的内存，但是并不是程序运行完成就实时回收，而是等系统内存濒临用完时才会进行回收  
3. 非new创建的内存如何处理  
Java提供了finalize()函数，可以将需回收的非new创建的对象的清理动作放进去，等Java垃圾回收机制运行时，会首先调用finalize()功能, finalize()中需要清理的非new创建的内存，将会在下一次垃圾回收时被清理。

4. 使用场景  
如果在类中调用了本地方法（如C语言的函数），其中malloc分配了内存，因此在对象使用后应该在finalize()中再此调用本地方法，如free()。这样才能释放内存，否则将造成内存泄漏。


##### 5.6 成员初始化

1. Java要求，所有变量在使用之前，都应该得到恰当的初始化  

2. 变量初始化的规则  
* 局部变量(即方法中的变量)：如果没有初始化，Java在编译时会提示错误  
* 成员变量(即类中定义的变量): 如果成员变量是基本数据类型，则提供默认初始化值；如果成员变量定义的是对象的引用，则会返回null   


##### 5.7 构造器初始化

1. 初始化顺序  
* 在类的内部，成员变量定义的顺序，决定了初始化的顺序  
* 成员变量初始化，优先于构造函数中变量的初始化

2. 静态数据的初始化  
* 无论创建多少个对象，静态数据都只会占用一块存储区域(公用）  
* static关键字不能用于局部变量  
* static关键字只能用于成员变量，成员方法

3. 显示的静态初始化  
* Java允许将多个静态初始化动作组成一个特殊的**静态子句**，有时称**静态块**  
* 示例：  
```
class Cups {
    static Cup cup1;
    static Cup cup2;
    static {
        cup1 = new Cup(1);
        cup2 = new Cup(2);
    }
}
```

4. 非静态实例初始化  
* 示例  
```
//非静态实例初始化，类似于静态初始化子句
class Mugs {
    Mug mug1;
    Mug mug2;
    {
        mug1 = new Mug(1);
        mug2 = new Mug(2);
    }
}
```
 

##### 5.8 数组初始化  

1. 数据是什么？  
* 数组是相同类型的，用一个标识符名称封装到一起的对象序列或基本数据类型序列  
* 数据是通过方括号下标操作符[]来定义使用的  

2. 数组的定义定义  
```
int a[];  
//或  
int[] a;
```

3. 可变参数列表  
* 由于所有的类都直接或间接继承于Object类，所以可以创建以Object数组为参数的方法，实现可变参数  
* 示例：  
```
static void printArray(Object[] obj) {  
    //.......
}

printArray( new Object[new Integer(1), new Float(2.0), new Double(1.1111)] );
```

4. 数组的初始化(两种方式)    
* 第一种：静态初始化(花括号{}初始化):   
  静态初始化表示程序员在初始化数组时为每个数组元素先赋值，由系统决定数组长度  

```
int[] a1 = {1, 2, 3, 4, 5};

User[] b = {
    new User(100, "张三"),
    new User(101, "李四"),
    new User(102, "王五")
    }
```


* 第二种：动态初始化(引用传递初始化)  
  动态初始化指程序员在初始化数组时指定数组长度，由编译器给数组元素分配初始值  

```
int[] a = new int[10];  //动态初始化，长度为10，各元素默认值由编译器指定为0

//后面就可以自己赋值了，覆盖编译器分配的默认值
for (int i=0; i<a.length; i++) {
    a[i] = 100;
}
```

* 变长数组的定义(元素为基本类型）  
```
//不能用new方式创建单个基本数据类型，但是可以创建数组元素
Random rand = new Randon(47);
int[] a = new int[ rand.newInt(20) ]; 
```

* 变长数组的定义(元素为对象）  
```
Random rand = new Randown(47);
Integer[] a = new Integer[ rand.newInt(20) ]; //记住：数组元素存储的是对象的**引用**
System.out.println(" length of a = " + a.length );

for ( int i=0; i<a.length(); i++ ) {
    a[i] = rand.nextInt(500);   //这里才对元素内容赋值了
}
System.out.println( Arrays.toString(a) );
```


##### 5.9 枚举类型

1. 枚举是什么？  
  枚举是一个被命名的整形常数的集合，用于申明一组带标示符的常熟  

2. 申明枚举  
```
//申明枚举使用enum关键字,如：
public enum SexEnum {
    MALE, FEMALE
} 

public enum Color {
    RED, BLUE, GREEN, BLACK
}
```

3. 使用枚举  
```
//枚举可以使switch语句的可读性更强，示例如：
enum Signal {
    GREEN, YELLOW, RED
}

public class TrafficLight {
    Signal color = Signal.RED;

    public void change() {
        switch( color ) {
            case RED:
                color = Signal.GREEN;   break;
            case YELLOW:
                color = Signal.RED;     break;
            case GREEN:
                color = Signal.YELLOW;  break;
        }
    }
}
```
